---
layout: single
title:  "Introduction to SQL for Data Science: The Main Statements You Need to Know"
date:   2023-03-04 10:38:07 +0100
categories: sql data select create where order delete drop alter group having join union window
permalink: "/:categories:title"
toc: true
toc_label: "My Table of Contents"
toc_sticky: true
---

SQL (Structured Query Language) is a programming language used to manage and manipulate relational databases. It is the standard language for interacting with databases and is widely used in data science. In this blog, we'll discuss what SQL is, why it's important in data science, and the main SQL statements to use for data science.

# What is SQL?

SQL is a programming language used to manage and manipulate relational databases. It is used to create, modify, and delete data in databases and retrieve data from them. SQL is a declarative language, meaning it describes what needs to be done, rather than how it needs to be done.

# Why is SQL important in Data Science?

Data Science relies on data, and data is often stored in databases. SQL allows data scientists to extract and manipulate data from databases, which is necessary for data analysis, modeling, and visualization. SQL is also important because it allows data scientists to work with large datasets, which would be difficult or impossible to manage without a database.

# Main SQL Statements for Data Science

These are the main SQL statements that will help us to perform the most of SQL statemens as a data scientists.

 - SELECT: This statement is used to retrieve data from a database. It allows you to specify which columns to recover, which rows to retrieve, and in what order to retrieve them.

 - WHERE: This statement is used to filter data based on specific conditions. It allows you to retrieve only the data that meets specific criteria.

 - JOIN: This statement is used to combine data from two or more tables into a single result set. It is important in data science because datasets are often spread across multiple tables.

 - GROUP BY: This statement is used to group data based on specific criteria. It allows you to perform aggregate functions on data, such as finding the average or maximum value.

 - HAVING: This statement is used to filter data that has been grouped using the GROUP BY statement. It allows you to filter based on aggregate functions, such as finding only groups that have an average value greater than a certain number.

 - ORDER BY: This statement is used to sort data based on specific criteria. It allows you to sort data in ascending or descending order, based on one or more columns.

 - CREATE: a powerful tool for defining the structure of your database and creating new database objects. By using this statement effectively, you can create databases that are well-organized, efficient, and easy to work with.

 - DELETE: a SQL statement that allows developers to remove unwanted data from their databases. By using this statement effectively and responsibly, you can ensure that your database remains accurate and up-to-date.

 - UPDATE: allows developers to modify existing data in their databases. By using this statement effectively and responsibly, you can ensure that your database remains accurate and up-to-date.

 - DROP: allows developers to delete unwanted data or objects from their databases. By using this statement effectively and responsibly, you can ensure that your database remains accurate and up-to-date.

 - ALTER: allows developers to adapt their databases to changing requirements while maintaining data integrity and consistency.

Let us now explore all of them. First, suppose ```table1```, ```table2```, ... is a table name to manipulate. This is used for general-purpose examples. For a specific purpose example we suppose the following tables:

 - ```employees``` table, that contains ```employee_id```, ```employee_name```, ```department```, and ```salary```, ```city``` columns. 
 - ```orders``` table with ```order_id```, ```customer_id```, ```product_name```, ```order_date```, ```total``` and ```order_amount``` columns.
 - ```customers``` table with ```customer_id```, ```customer_name``` and ```email```, ```city``` columns.

## SELECT 

The first statement that we want to explore is the SELECT statement. This statement retrieves data from a database. It allows you to specify which columns to recover, which rows, and in what order they should be retrieved. Here are some examples of using the SELECT statement.

### SELECT all values
If we have a table and we want to select all the columns from it we will use:

```
SELECT * 
FROM table1;
```

An example of such a selection would be 

```
SELECT *
FROM employees
```

### SELECT specific columns
However, sometimes we need just a few of the columns. In this situation we use:

```
SELECT column1, column2, column3 
FROM table1;
```

Here is an example of this statement using the ```employees``` table:

```
SELECT employee_name, department, salary 
FROM table1;
```

In the previous example, we did not select the ```employee_id``` column.


### SELECT column and rename it
Sometimes we want to select a column and give it a specific name, therefore to select and rename the column from a table we use the keyword ```AS```.

```
SELECT column1 
AS new_column_name 
FROM table1;
```

or to select the ```employee_name``` column by naming it ```name``` we do as follows:

```
SELECT employee_name 
AS name 
FROM employees;
```

### SELECT unique values
To select only the unique values from a column or a set of columns we will use the ```DISTINCT```keyword. It removes the duplicate values from the result set, so each row in the result set is unique.

```
SELECT DISTINCT column1 
FROM table1;
```

Here's an example: suppose we have a table called employees with columns for employee_id, employee_name, department, and salary. We can use the ```DISTINCT``` keyword to retrieve a list of unique departments in the table, like this:

```
SELECT DISTINCT department FROM employees;
```

This query will return a list of all unique values in the department column of the employees table.

One thing to keep in mind is that the DISTINCT keyword applies to all columns listed in the SELECT statement, not just the one column specified after the keyword. For example, if we modify the above query to select both the department and salary columns:

```
SELECT DISTINCT department, salary FROM employees;
```

This query will return a list of all unique combinations of the department and salary columns in the employees table.

It's also worth noting that using the DISTINCT keyword can have performance implications, as the database needs to compare values in each column to determine uniqueness. For very large tables or complex queries, using DISTINCT may be slower than other methods of filtering or aggregating data.



### SELECT with condition(s)
To select values from a table that meet a certain condition we use ```WHERE``` as in the following example:

```
SELECT * 
FROM table1 
WHERE column1 = 'value';
```

Also selecting multiple conditions we use ```AND```. 

```
SELECT * FROM table1 
WHERE column1 = 'value' 
AND column2 = 'value';
```

### SELECT with pattern
To select values from a table using a pattern match use ```LIKE``` keyword as in the following example:

```
SELECT * 
FROM table1 
WHERE column1 
LIKE '%value%';
```

In SQL, the LIKE operator is used to select data from a table based on pattern matching. The LIKE operator is typically used with the ```%``` and ```_``` wildcards, which represent any string of characters and any single character, respectively.

Here's an example: suppose we have a table called customers with columns for customer_id, customer_name, and email. We can use the LIKE operator to find all customers whose email addresses contain the word "gmail", like this:

```
SELECT * 
FROM customers 
WHERE email LIKE '%gmail%';
```

This query will return all rows from the customers table where the email column contains the string "gmail". The % wildcard matches any string of characters, so the query will return rows where "gmail" appears anywhere in the email column.

We can also use the _ wildcard to match any single character. For example, if we want to find all customers whose email addresses end in ".com", we can use this query:

```
SELECT * FROM customers WHERE email LIKE '%.com';
```

In this case, the % wildcard matches any string of characters before the ".com" suffix, and the ```_``` wildcard matches any single character before the suffix.

It's worth noting that the LIKE operator is case-insensitive by default, so it will match both uppercase and lowercase characters. If you need to perform case-sensitive pattern matching, you can use the LIKE BINARY operator instead.

Overall, pattern matching with the LIKE operator is a powerful tool for selecting data based on complex criteria. By using wildcards and string patterns, you can search for specific patterns in your data and retrieve only the rows that match.


### SELECT ASC/DESC
Also, we can make a selection by ordering in ascending or descending order as in the following example:

```
SELECT * 
FROM table1 
ORDER BY column1 ASC;

SELECT * 
FROM table1 
ORDER BY column1 DESC;
```

The ```ORDER BY``` clause is used to sort the results of a query in ascending or descending order. By default, ORDER BY sorts the results in ascending order based on the specified column(s). To sort in descending order, we can add the DESC keyword after the column name.

Supposing the employees table example. We can use the ```ORDER BY``` clause to sort the results of a query based on the salary column, like this:

```
SELECT * 
FROM employees 
ORDER BY salary ASC;
```

This query will return all rows from the employees table, sorted in ascending order based on the salary column. The ASC keyword is optional, since ascending order is the default. However, if we want to sort the eployees in descending order of salary, we must use the DESC keyword as follows:

```
SELECT * 
FROM employees 
ORDER BY salary DESC;
```


It's worth noting that we can also sort the results based on multiple columns. For example, if we want to sort the employees table by department first, and then by salary within each department, we can use this query:

```
SELECT * 
FROM employees 
ORDER BY department ASC, salary DESC;
```

In conclusion, ```ORDER BY``` clause is a powerful tool for sorting query results based on one or more columns. By using ```ASC``` and ```DESC``` keywords, we can control the order in which the results are sorted to meet our specific needs.

### SELECT limiting the number of rows
Select values from a table and limit the number of rows returned use ```LIMIT```:

```
SELECT * 
FROM table1 
LIMIT 10;
```


## WHERE

By using the ```WHERE``` statement, data can be filtered based on a specific condition. We will be able to retrieve data that meets specific criteria. ```WHERE``` statements are used in conjunction with ```SELECT``` statements to retrieve specific data from a database that meets certain criteria.

Taking the employee table example as an example. With the WHERE statement, we can select only those employees working in the "Sales" department who earn a salary greater than 30,000 euros, as shown below:

```
SELECT * 
FROM employees 
WHERE department = 'Sales' AND salary > 30000;
```

This query will return all rows from the employees table where the department column is equal to "Sales" and the salary column is greater than 50,000. The ```AND``` keyword is used to combine multiple conditions, so both conditions must be true for a row to be included in the result set.

The ```WHERE``` statement can also be used with other operators such as ```OR```, ```NOT```, ```BETWEEN```, ```IN```, and ```LIKE``` to further refine the selection criteria. For example, we can use the ```LIKE``` operator to find all employees whose last name starts with "S", like this:

```
SELECT * FROM employees WHERE employee_name LIKE 'S%';
```


## JOIN

In relational databases, data is often spread across multiple tables, each containing specific pieces of information. To retrieve meaningful information from these tables, we need to be able to combine or join them together. The JOIN operation allows us to do just that. 

JOIN operation combines rows from two or more tables into a single result set based on a related column between them. The related column is often called a _join column_ or _foreign key_.

There are different types of JOIN operations: 
 - INNER JOIN
 - LEFT JOIN
 - RIGHT JOIN
 - FULL OUTER JOIN

Each type of JOIN is used to retrieve different sets of data from the tables being joined. To be comfortable with the manipulation of multiple tables by combining them we need to understand all these types of join.

For a short cheat sheet I propose you to take a look at the one prepared by Data Camp by clicking on the [link](/assets/img-blog/sql/SQL_Joins_Cheat_Sheet.pdf).

Also, the following picture of sql.sh illustrates the SQL JOINS:

{% include figure image_path="/assets/img-blog/sql/sql-join-infographie.png" alt="this is a placeholder image" caption="Figure 1: SQL JOINS" %}


### INNER JOIN

```
SELECT *
FROM table1
JOIN table2
ON table1.column = table2.column;
```

In SQL this is considered to be the most common type of JOIN. 
It returns all rows from both tables where the join condition is true. In other words, it only returns rows that have a matching value in both tables.

Let us see an example of this. 

```
SELECT customers.customer_id, customers.customer_name, orders.order_id, orders.order_date
FROM customers
INNER JOIN orders
ON customers.customer_id = orders.customer_id;
```

Here, we are joining the ```customers``` table with the ```orders``` table on the ```customer_id``` column. The ```SELECT``` statement returns the ```customer_id``` and ```customer_name``` columns from the ```customers``` table, as well as the ```order_id``` and ```order_date``` columns from the ```orders``` table. The ```ON``` clause specifies the join condition, which is that the ```customer_id``` column in the ```customers``` table must match the ```customer_id``` column in the ```orders``` table.

### LEFT JOIN

```
SELECT *
FROM table1
LEFT JOIN table2
ON table1.column = table2.column;
```

Another type of JOIN in SQL is the ```LEFT JOIN```. It returns all rows from the left table (the first table listed in the JOIN statement) and the matching rows from the right table (the second table listed in the JOIN statement). If there is no match in the right table, the result will contain ```NULL``` values for the right table columns.

Let us see an example of this:

```
SELECT customers.customer_id, customers.customer_name, orders.order_id, orders.order_date
FROM customers
LEFT JOIN orders
ON customers.customer_id = orders.customer_id;
```

In this example, we are joining the ```customers``` table with the ```orders``` table on the ```customer_id``` column using a ```LEFT JOIN```. The ```SELECT``` statement returns the ```customer_id``` and ```customer_name``` columns from the ```customers``` table, as well as the ```order_id``` and ```order_date``` columns from the ```orders``` table. Because this is a ```LEFT JOIN```, all rows from the ```customers``` table will be returned, even if there is no matching row in the ```orders``` table.

### RIGHT JOIN

```
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.column = table2.column;
```

Here, ```RIGHT JOIN``` is similar to ```LEFT JOIN```, but it returns all rows from the right table (the second table listed in the ```JOIN``` statement) and the matching rows from the left table (the first table listed in the ```JOIN``` statement). If there is no match in the left table, the result will contain ```NULL``` values for the left table columns.

Let us dive into an example of the ```RIGHT JOIN```.

```
SELECT customers.customer_id, customers.customer_name, orders.order_id, orders.order_date
FROM customers
RIGHT JOIN orders
ON customers.customer_id = orders.customer_id;
```

In this example we are right joining ```customers``` and ```orders```tables, selecting 4 columns. The ```RIGHT JOIN```is performed on the ```customer_id``` column, which is present in both tables. The ```ON``` keyword specifies the join condition, which in this case is ```customers.customer_id = orders.customer_id```. This means that only rows with matching customer_id values in both tables will be included in the result set. 

Since this is a ```RIGHT JOIN```, the query will return all the rows from the orders table, along with the matching rows from the ```customers``` table. If there is no matching row in the ```customers``` table for a given order, the result will still include the row from the orders table, with null values for the columns in the ```customers``` table.


### FULL OUTER JOIN

```
SELECT *
FROM table1
FULL OUTER JOIN table2
ON table1.column = table2.column;
```

This type of join returns all the rows from both tables, along with the matching rows. If there is no matching row in one of the tables, the result will still include the row from that table, with null values for the columns in the other table. 

Let's say we want to see a list of all the customers and their orders, including customers who have not placed any orders and orders that do not have a corresponding customer, sorted by customer name in ascending order. We can use a FULL OUTER JOIN to combine the two tables as follows:

```
SELECT customers.customer_id, customers.customer_name, orders.order_id, orders.order_date
FROM customers
FULL OUTER JOIN orders
ON customers.customer_id = orders.customer_id
ORDER BY customers.customer_name ASC;
```

This query will return all the rows from both the ```customers``` and ```orders``` tables, regardless of whether there is a matching row in the other table. If there is no matching row in the ```orders``` table for a given ```customer```, the result will still include the row from the ```customers``` table, with ```null``` values for the columns in the ```orders``` table. Similarly, if there is no matching row in the ```customers``` table for a given ```order```, the result will still include the row from the ```orders``` table, with ```null``` values for the columns in the ```customers``` table. We also added ```ORDER BY``` clause that sorts the result set by customer_name in ascending order.

As we see ```FULL OUTER JOIN``` is useful when we want to include all the rows from both tables, even if there is no corresponding data in the other table. This can be useful for situations where we want to analyze all the data we have available, regardless of whether it is complete or not.

## GROUP BY

The ```GROUP BY``` clause is used to group the rows of a result set based on the values in one or more columns. This is typically used in conjunction with an aggregate function (such as ```SUM```, ```COUNT```, or ```AVG```) to calculate summary information for each group.

Supposing the orders table example. We can use the ```GROUP BY``` clause to group the orders by customer, and then calculate the total amount spent by each customer, like this:

```
SELECT customer_id, SUM(order_amount) as total_spent
FROM orders
GROUP BY customer_id;
```

This query will return a summary of the orders table, grouped by ```customer_id```. For each customer, the query will calculate the total amount spent (using the ```SUM``` function) and return it as ```total_spent```.

The GROUP BY clause can also be used to group by multiple columns. For example, we can group the orders by both customer_id and product_name, and then calculate the total amount spent on each product by each customer, like this:

```
SELECT customer_id, product_name, SUM(order_amount) as total_spent
FROM orders
GROUP BY customer_id, product_name;
```

This query will return a summary of the orders table, grouped first by customer_id and then by product_name. For each combination of customer and product, the query will calculate the total amount spent (using the SUM function) and return it as total_spent.

## HAVING

The ```HAVING``` clause is used in conjunction with the ```GROUP BY``` clause to filter the results of a query based on a condition that applies to groups of rows rather than individual rows. The ```HAVING``` clause is similar to the ```WHERE``` clause, but operates on the grouped results of a query rather than on individual rows.

Let us explore the ```orders``` table for example. We want to group the orders by customer, and then filter the results to include only those customers who have spent more than 500 euros. The SQL code would look like this:

```
SELECT customer_id, SUM(order_amount) as total_spent
FROM orders
GROUP BY customer_id
HAVING SUM(order_amount) > 500;
```

This query will group the orders by customer_id, calculate the total amount spent by each customer, and then include only those customers whose total spent amount is greater than $1000 (using the HAVING clause).

The ```HAVING``` clause can also be used with other aggregate functions such as ```COUNT```, ```MIN```, ```MAX```, and ```AVG``` to filter the grouped results based on various conditions. For example, we can use the ```HAVING``` clause to include only those customers who have placed more than 3 orders, like this:

```
SELECT customer_id, COUNT(*) as num_orders
FROM orders
GROUP BY customer_id
HAVING COUNT(*) > 3;
```

This query will group the orders by customer_id, count the number of orders placed by each customer, and then include only those customers who have placed more than 3 orders.

## ORDER BY

The ORDER BY clause is used to sort the rows of a result set based on the values in one or more columns. The ORDER BY clause is typically used at the end of a query and can be used to sort the results in either ascending or descending order. Taking the ```orders``` table example.

```
SELECT * FROM orders
ORDER BY order_amount DESC;
```

This query will return all the rows in the ```orders``` table, sorted by ```order_amount``` in descending order (using the ```DESC``` keyword).

The ```ORDER BY``` clause can also be used to sort by multiple columns. For example, we can sort the results by ```product_name``` in ascending order, and then by ```order_amount``` in descending order, like this:

```
SELECT * FROM students
ORDER BY product_name ASC, order_amount DESC;
```

This query will return all the rows in the orders table, sorted first by product_name in ascending order, and then by order_amount in descending order.

## UNION

The UNION statement in SQL is used to combine the results of two or more SELECT statements into a single result set. This is a powerful tool for data analysis, as it allows us to easily merge data from different tables or queries and perform further analysis on the combined data set.

When using the UNION statement, it's important to keep in mind that each SELECT statement must have the same number of columns, and the columns must have the same data types in the same order. Additionally, the columns should have compatible data types, so that they can be combined without issues.

Here's an example of using the UNION statement to combine data from two tables:

```
SELECT column1, column2, column3
FROM table1
UNION
SELECT column1, column2, column3
FROM table2;
```

In this example, we have two tables, ```table1``` and ```table2```, with the same structure. We want to combine the data from both tables and select columns ```column1```, ```column2```, and ```column3```. The ```UNION``` statement is used to merge the results of the two ```SELECT``` statements into a single result set.

The resulting output will contain all the distinct rows from both tables, with any duplicates removed. If there are duplicates within each table, they will also be removed. If we want to include duplicates in the result set, we can use the ```UNION ALL``` statement instead of ```UNION```.

Here's an example of using ```UNION ALL``` to combine data from two tables:

```
SELECT column1, column2, column3
FROM table1
UNION ALL
SELECT column1, column2, column3
FROM table2;
```

This query will combine the data from ```table1``` and ```table2```, including any duplicates, into a single result set.

The ```UNION``` statement can also be used with subqueries to combine the results of multiple queries. For example:

```
SELECT column1, column2, column3
FROM table1
WHERE column1 = 'value'
UNION
SELECT column1, column2, column3
FROM table2
WHERE column2 = 'value';
```

In this example, we're using the UNION statement to combine the results of two subqueries. The first subquery selects rows from table1 where column1 is equal to 'value', while the second subquery selects rows from table2 where column2 is equal to 'value'. The UNION statement is used to merge the results of the two subqueries into a single result set.


Now let us look for an specific example. Let's use the UNION statement to combine the first names and last names of customers with the order dates from the orders table, to see a list of all customers and their order dates:

```
SELECT customer_name AS name, city
FROM customers
WHERE city = 'Lyon'
UNION
SELECT employee_name AS name, city
FROM employees
WHERE city = 'Lyon';
```

This query combines the ```customer``` and the ```employees``` by using the ```UNION```statement. In the ```SELECT```statement we see that the names and the cities of customer and respectively the employees are selected with a condition of ```city```to be in Lyon. Therefore the previous query will return a list of employees and customers from Lyon city giving their names.


## Window function

Window functions are a powerful feature in SQL that allows you to perform calculations over a specified set of rows in a result set. Unlike traditional aggregate functions, window functions do not group the results into a single row. Instead, they compute a value for each row in the result set based on a defined window or subset of rows.

Window functions are commonly used to calculate moving averages, running totals, and rankings in SQL queries. We explore the syntax and usage of window functions in SQL, using examples.

### Syntax of Window Functions

The basic syntax of a window function in SQL is as follows:

```
SELECT column1, column2, ..., function(column) OVER (PARTITION BY column1 ORDER BY column2)
FROM table
```

The ```OVER``` clause is used to specify the window or subset of rows over which the function should be calculated. The ```PARTITION BY``` clause is used to divide the result set into partitions or groups based on a specified column or columns. The ```ORDER BY``` clause is used to sort the rows within each partition.

### Types of Window Functions

There are several types of window functions that can be used in SQL queries. Some of the most common ones include:

- Aggregate Functions: These functions compute a single result for a group of rows within a window. Examples include SUM, AVG, MIN, and MAX.
- Ranking Functions: These functions assign a rank or position to each row within a window. Examples include RANK, DENSE_RANK, and ROW_NUMBER.
- Analytic Functions: These functions compute a value for each row within a window based on the values of other rows. Examples include LAG, LEAD, and FIRST_VALUE.

### Aggregate Functions

Let's consider an example of a table ```sales``` that contains the following data:

```
date	product	sales
2022-01-01	A	100
2022-01-01	B	200
2022-01-02	A	150
2022-01-02	B	250
2022-01-03	A	125
2022-01-03	B	225
```

We will use the ```SUM``` aggregate function as a window function to calculate the running total of sales for each product.

```
SELECT date, product, sales, 
       SUM(sales) OVER (PARTITION BY product ORDER BY date) AS running_total
FROM sales;
```

In the query above, we are selecting the date, product, and sales columns from the sales table. We are also using the SUM aggregate function as a window function to calculate the running total of sales for each product.

The SUM function is being applied over a partition of the data defined by the PARTITION BY clause. In this case, we are partitioning the data by product. This means that the running total will be calculated separately for each product.

The ORDER BY clause specifies the order in which the SUM function should be applied. In this case, we are ordering the rows by date, which means that the running total will be calculated based on the order of dates within each partition.

The output of the query would be:

```
date	product	sales	running_total
2022-01-01	A	100	100
2022-01-02	A	150	250
2022-01-03	A	125	375
2022-01-01	B	200	200
2022-01-02	B	250	450
2022-01-03	B	225	675
```

As you can see, the running total is calculated separately for each product, and the value for each row is based on the sum of sales up to and including that row. This is just one example of how window functions can be used to perform complex calculations on your data.

### Ranking Functions

Ranking functions are a type of window function in SQL that assign a rank or row number to each row in a result set based on a specific criterion. There are three types of ranking functions in SQL: RANK(), DENSE_RANK(), and ROW_NUMBER().

Let's consider an example of a table ```sales``` as in the previous example. We will use the RANK and DENSE_RANK ranking functions to assign a rank to each product based on its sales.

```
SELECT date, product, sales, 
       RANK() OVER (ORDER BY sales DESC) AS rank,
       DENSE_RANK() OVER (ORDER BY sales DESC) AS dense_rank
FROM sales;
```

In the query above, we are selecting the date, product, and sales columns from the sales table. We are also using the RANK and DENSE_RANK ranking functions to assign a rank to each product based on its sales.

The RANK function assigns a unique rank to each product based on its sales, with ties receiving the same rank. For example, if two products have the same sales value, they will receive the same rank, and the next rank will be skipped.

The DENSE_RANK function assigns a unique rank to each product based on its sales, with ties receiving the same rank, but the next rank is not skipped. For example, if two products have the same sales value, they will receive the same rank, and the next rank will not be skipped.

The output of the query would be:

```
date	product	sales	rank	dense_rank
2022-01-02	B	250	1	1
2022-01-01	B	200	2	2
2022-01-02	A	150	3	3
2022-01-03	B	225	4	4
2022-01-03	A	125	5	5
2022-01-01	A	100	6	6
```

As you can see, the RANK and DENSE_RANK functions have assigned a rank to each product based on its sales, with ties receiving the same rank according to the criteria defined in the ORDER BY clause. This is just one example of how ranking functions can be used to assign a rank or row number to each row in a result set based on a specific criterion.

### Analytic Functions

Analytic functions are a type of window function in SQL that perform calculations across multiple rows in a result set, without collapsing the result set into a single row. Analytic functions are commonly used to calculate running totals, moving averages, and other aggregate values that are computed over a specific window of rows.

Let's consider an example of a table ```sales``` as in the previous example.

We will use the ```SUM``` analytic function to calculate the running total of sales for each product.

```
SELECT date, product, sales, 
       SUM(sales) OVER (PARTITION BY product ORDER BY date) AS running_total
FROM sales;
```

In the query above, we are selecting the date, product, and sales columns from the sales table. We are also using the ```SUM``` analytic function to calculate the running total of sales for each product.

The SUM function is applied over a specific window of rows defined by the ```PARTITION BY``` and ```ORDER BY``` clauses. In this case, we are partitioning the data by the product column and ordering it by the date column. This means that the ```SUM``` function will calculate the running total of sales for each product, based on the order of dates.

The output of the query would be:

```
date	product	sales	running_total
2022-01-01	A	100	100
2022-01-02	A	150	250
2022-01-03	A	125	375
2022-01-01	B	200	200
2022-01-02	B	250	450
2022-01-03	B	225	675
```

As you can see, the ```SUM``` analytic function has calculated the running total of sales for each product based on the order of dates, without collapsing the result set into a single row. This is just one example of how analytic functions can be used to perform calculations across multiple rows in a result set, without collapsing the result set into a single row.

## CREATE
The ```CREATE``` statement is used to create new database objects, such as tables, views, indexes, and stored procedures. This statement is an essential component of database management, allowing developers to define and organize the structure of their database.

Let us see the syntax of the ```CREATE``` statement of SQL.
```
CREATE TABLE table_name (
   column1 datatype1,
   column2 datatype2,
   column3 datatype3,
   .....
   columnN datatypeN
);

```

In this statement, table_name is the name of the table you wish to create, and column1, column2, column3, and columnN are the names of the columns you wish to include in the table. datatype1, datatype2, datatype3, and datatypeN are the data types of the columns, such as int, varchar, or datetime.

For example let us  create a table named employees with columns for id, first_name, last_name, email, and hire_date, you would use the following statement:

```
CREATE TABLE employees (
   id INT NOT NULL PRIMARY KEY,
   first_name VARCHAR(50),
   last_name VARCHAR(50),
   email VARCHAR(50),
   hire_date DATE
);
```

This statement would create a new table named employees with columns for id, ```first_name```, ```last_name```, ```email```, and ```hire_date```. The id column is defined as an integer data type with a ```NOT NULL``` constraint, indicating that a value must be provided for this column. It is also defined as the primary key of the table, ensuring that each record in the table is unique. The remaining columns are defined as ```VARCHAR``` and ```DATE``` data types.

In addition to creating tables, the CREATE statement can be used to create a variety of other database objects. For example, to create a new view, you would use the following syntax:

```
CREATE VIEW view_name AS
   SELECT column1, column2, column3, .....
   FROM table_name
   WHERE condition;
```

In this statement, ```view_name``` is the name of the ```view``` you wish to create, and ```table_name``` is the name of the table you wish to use as the basis for the view. The ```SELECT``` statement specifies the columns you wish to include in the view, and the ```WHERE``` clause specifies any conditions that must be met for a record to be included in the view.


## INSERT

The ```INSERT``` statement is used to add new data to a table. This statement is a fundamental part of database management, allowing developers to populate their database with the data they need.

To insert a new row into a table, you would use the following syntax:

```
INSERT INTO table_name (column1, column2, column3, ..., columnN)
VALUES (value1, value2, value3, ..., valueN);
```

In this statement, table_name is the name of the table you wish to insert data into, and ```column1```, ```column2```, ```column3```, and ```columnN``` are the names of the columns you wish to add data to. ```value1```, ```value2```, ```value3```, and ```valueN``` are the values you wish to insert into the corresponding columns.

For example, to insert a new row into a table named employees with values for id, first_name, last_name, email, and hire_date, you would use the following statement:

```
INSERT INTO employees (id, first_name, last_name, email, hire_date)
VALUES (1, 'Marius', 'Bartcus', 'mbartcus@gmail.com', '2022-03-01');
```

This statement would add a new row to the employees table with an id of 1, a ```first_name``` of "Marius", a ```last_name``` of "Bartcus", an ```email``` of "mbartcus@gmail.com", and a ```hire_date``` of "2022-03-01".

In addition to inserting individual rows, the ```INSERT``` statement can also be used to insert multiple rows at once. To do this, you would use a slightly different syntax:

```
INSERT INTO table_name (column1, column2, column3, ..., columnN)
VALUES (value1, value2, value3, ..., valueN),
       (value1, value2, value3, ..., valueN),
       (value1, value2, value3, ..., valueN),
       ...;

```

In this statement, you can specify multiple sets of values to be inserted, separated by commas.

Overall, the ```INSERT``` statement is a critical part of SQL that allows developers to add new data to their databases. By using this statement effectively, you can ensure that your database is populated with the data you need to accomplish your goals.


## DELETE

The ```DELETE``` statement is used to remove one or more rows from a table. This statement is a fundamental part of database management, allowing developers to delete data that is no longer needed or is incorrect.

To delete rows from a table, you would use the following syntax:

```
DELETE FROM table_name
WHERE condition;
```

In this statement, table_name is the name of the table you wish to delete data from, and the condition is the condition that specifies which rows to delete. If the condition is true for a row, that row will be deleted.

For example, to delete all rows from a table named employees where the id is equal to 1, you would use the following statement:

```
DELETE FROM employees
WHERE id = 1;
```

This statement would remove all rows from the ```employees``` table where the id is equal to 1.

In addition to deleting specific rows based on a condition, the ```DELETE``` statement can also be used to delete all rows from a table. To do this, you would use the following syntax:

```
DELETE FROM table_name;
```

This statement would remove all rows from the specified table.

It is important to note that the ```DELETE``` statement permanently removes rows from a table. Therefore, it is crucial to use this statement with caution and to always double-check the conditions used in the ```WHERE``` clause before executing the statement.

The ```DELETE``` statement is a critical part of SQL that allows developers to remove unwanted data from their databases. By using this statement effectively and responsibly, you can ensure that your database remains accurate and up-to-date.

## UPDATE

The ```UPDATE``` statement is used to modify existing data in a table. This statement is a fundamental part of database management, allowing developers to make changes to data that has already been inserted.

To update rows in a table, you would use the following syntax:

```
UPDATE table_name
SET column_name1 = value1, column_name2 = value2, ...
WHERE condition;
```

In this statement, ```table_name``` is the name of the table you wish to update data in, column_name is the name of the column you wish to update, and ```value``` is the new value you wish to set. The ```WHERE``` clause specifies which rows to update. If the condition is true for a row, that row will be updated.

For example, to update the salary column for a row in a table named employees where the id is equal to 1, you would use the following statement:

```
UPDATE employees
SET salary = 50000
WHERE id = 1;
```

This statement would set the salary column to 50000 for the row in the employees table where the id is equal to 1.

In addition to updating specific rows based on a condition, the UPDATE statement can also be used to update all rows in a table. To do this, you would use the following syntax:

```
UPDATE table_name
SET column_name = value;
```

This statement would set the value of the specified column to the specified value for all rows in the table.

It is important to note that the ```UPDATE``` statement can permanently modify data in a table. Therefore, it is crucial to use this statement with caution and to always double-check the conditions used in the ```WHERE``` clause before executing the statement.

## DROP

The ```DROP`` statement is used to remove an entire database, table, or view. This statement is a fundamental part of database management, allowing developers to delete unwanted data or objects from their databases.

The basic syntax for using the DROP statement is as follows:

```
DROP object_type object_name;
```

In this statement, ```object_type``` is the type of object you wish to remove (e.g. ```DATABASE```, ```TABLE```, ```VIEW```) and ```object_name``` is the name of the object you wish to delete.

For example, to drop a table named ```employees```, you would use the following statement:

```
DROP TABLE employees;
```

This statement would delete the entire employees table and remove all data and metadata associated with that table.

It is important to note that the DROP statement permanently removes data or objects from a database, and this action cannot be undone. Therefore, it is crucial to use this statement with caution and to ensure that you are deleting the correct objects.

Another important consideration when using the ```DROP``` statement is the use of the ```CASCADE``` option. This option allows you to remove not only the specified object but also any dependent objects that rely on the specified object. For example, if you have a table with foreign key constraints that reference another table, you would need to use the ```CASCADE``` option to remove both the table and the dependent constraints.

```
DROP TABLE table_name CASCADE;
```

## ALTER

The ```ALTER``` statement is used to modify the structure of existing database objects such as tables, columns, and constraints. This statement is an essential part of database management, allowing developers to adapt their databases to changing requirements.

The basic syntax for using the ALTER statement is as follows:

```
ALTER object_type object_name action;
```

In this statement, object_type is the type of object you wish to modify (e.g. TABLE, COLUMN, CONSTRAINT) and object_name is the name of the object you wish to alter. The action parameter specifies the change you want to make to the object.

For example, to add a new column named phone to an existing table named customers, you would use the following statement:

```
ALTER TABLE customers ADD phone varchar(10);
```

This statement would modify the customers table by adding a new column named phone with a varchar data type of length 10.

Other examples of actions you can perform with the ALTER statement include modifying the data type or length of an existing column, renaming an object, or dropping a constraint.

It is important to note that some modifications made to the ```ALTER``` statement can affect the data already stored in the database. For example, changing the data type of a column may result in data loss or unexpected behavior. Therefore, it is crucial to carefully consider the impact of any changes made to the ```ALTER``` statement before executing them.

Another important consideration when using the ```ALTER``` statement is the use of transactions. Because the ```ALTER``` statement can modify the structure of a database object, it is crucial to ensure that the database remains in a consistent state throughout the modification process. By using transactions, developers can group related ```ALTER``` statements together and ensure that the database is only modified if all statements are executed successfully.


# Conclusion

SQL is an important tool for data scientists, as it allows them to work with databases and manipulate data. Understanding the main SQL statements is essential for anyone who wants to work in data science, as it allows them to extract and manage data efficiently. By mastering SQL, you can become a more effective data scientist and work with larger datasets, which can provide more insights and better results.